# LeetCode 24.交换链表节点

## 思路

循环外需要先声明两个指针，一个**prev**指向转换后的最后一个节点，一个**curr**表示下一个需要交换的第一个节点（curr指向的节点的next属性已经暗含了第二个节点，所以不需要再额外声明新的指针了），因为循环体需要访问操作prev.next属性，所以循环前还需要创建一个**虚拟节点dummy**，**while终止条件就是curr为null或者curr的下一个节点为null，** **每次循环要做的就是更新prev.next\curr.next\curr.next.next这几个属性的值就可以**了，完成交换之后，同时移动prev和curr准备下一次的循环

## 解法一 迭代

时间：O(n)

空间：O(1)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
    let dummy=new ListNode(0,head)
    let pre = dummy
    let curr=head
    while(curr){
        let next=curr.next
        //需要交换的第二个节点为空时，也需要终止循环
        if(next===null) break
        let tail=next.next
        //交换节点
        pre.next=next
        next.next=curr
        curr.next=tail
				//移动节点准备下次循环
        pre=curr
        curr=tail
    }
    return dummy.next
};
```



# LeetCode 19.删除链表的倒数第N个节点

## 思路

**计算长度**

第一遍遍历先计算链表长度，第二遍遍历再找到倒数第n个节点删除，删除节点的操作和203题一样

**双指针**

用双指针可以不用提前计算出链表的长度，前n次循环只需要让第一个指针先往前走n步，然后后面的循环第二个指针和第一个指针一起往链表后面走，因为俩个指针之间**相隔n个节点**，所有当第一个指针为null时，第二个指针之前的位置就是倒数第n个节点了

## 解法一 计算长度

时间：O(n)

空间：O(1)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    let dummy=new ListNode(0,head)
    let prev=dummy
    let curr=head
    let len=0
    //第一次遍历先计算出链表的长度
    while(curr){
        len++
        curr=curr.next
    }
    curr=head
    let i=0
    while(curr){
        if(i===len-n){
            prev.next=curr.next
            break;
        }else{
            i++
            prev=curr
            curr=curr.next
        }
    }
    return dummy.next
};
```

## 解法二 双指针

时间：O(n)

空间：O(1)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
    let dummy=new ListNode(0,head)
    let prev=dummy
    let first=head
    let i=0 //表示第一个指针走了多少步
    while(first){
        if(i>=n){
          //当第一个指针往前走n步之后，第二个指针跟着第一个指针一起往后走
            prev=prev.next
        }
        first=first.next
        i++
    }
  //删除第n个节点
    prev.next=prev.next.next
    return dummy.next
};
```

# LeetCode 160.相交链表

## 思路

**哈希表**

相交就是地址相同，只需要分别先遍历其中一个链表将所有节点的地址存储起来，再遍历第二个链表看哈希表中是否有相同的地址

**双指针**

哈希表的解法一般都需要创造额外的存储空间，**对于链表的题目如果想继续降低空间复杂度一般都需要双指针**，先考虑一种两个链表长度相等的特殊情况：长度相等同时遍历两链表，两个指针一定是同时到达相交的节点。所以只要消除两个链表的长度差，让两个指针同时遍历相同数目的节点即可。

**双指针（官方解法）**

消除长度差的双指针解法，虽然比较好理解，但是实现的代码不够简洁，官方这种方法非常简洁，就是pA指针和pB指针分别同时开始遍历两个链表，遍历完的指针再重新遍历另一个链表，这样两个指针分别遍历了两个链表，走的节点数也就相同了。

## 解法一 哈希表

时间：O(n)

空间：O(n)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    let set =new Set()
    while(headA){
        set.add(headA)
        headA=headA.next
    }
    while(headB){
        if(set.has(headB)){
            return headB
        }
        headB=headB.next
    }
    return null
};
```

## 解法二 双指针 ⭐️

时间：O(n)

空间：O(1)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    let lenA=0
    let lenB=0
    let currA=headA
    let currB=headB
    //分别遍历计算两个链表的长度
    while(currA){
        lenA++
        currA=currA.next
    }
    while(currB){
        lenB++
        currB=currB.next
    }
    let i=0
    currA=headA
    currB=headB
  	//移动更长的那个链表，消除链表的长度差
    if(lenA>lenB){
        while(i<lenA-lenB){
            i++
            currA=currA.next
        }
    }else if(lenA<lenB){
        while(i<lenB-lenA){
            i++
            currB=currB.next
        }
    }
  	//此时两个链表已经没有长度差了，两个链表同时移动到两个指针相等时就是相交的节点
    while(currA&&currB){
        if(currA===currB){
            return currA
        }
        currA=currA.next
        currB=currB.next
    }
    return null
};
```

## 解法三 双指针（官方解法）⭐️

时间：O(n)

空间：O(1)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
var getIntersectionNode = function(headA, headB) {
    if(headA===null||headB===null) return null
    let pA=headA
    let pB=headB
    while(pA!==pB){
        pA===null?pA=headB:pA=pA.next;
        pB===null?pB=headA:pB=pB.next;
    }
    return pA
};
```



# LeetCode 142.环形链表II ⭐️

## 思路

**哈希表**

最直观能想到的就是用哈希表，如果是环形链表，那么环形入口节点一定会是第一个在哈希表中被再次访问到

**快慢指针**



## 解法一 哈希表

时间：O(n)

空间：O(n)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    let set=new Set()
    let curr=head
    while(curr){
        if(set.has(curr)){
            return curr
        }else{
            set.add(curr)
            curr=curr.next
        }
    }
    return null
};
```

## 解法二 快慢指针

