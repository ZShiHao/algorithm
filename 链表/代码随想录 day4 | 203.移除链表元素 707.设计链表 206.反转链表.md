# LeetCode 203.移除链表元素

## 思路

比较简单，主要看对链表的理解，需要定义两个指针，**一个指针指向当前正在遍历的节点，一个节点指向当前节点的上一个节点**（因为删除节点时，要更新上一个节点的next地址，所以要时刻保存上一个节点的地址），链表还有一个注意点：一般对头指针head会新创建一个**虚拟节点**，方便删除头结点

## 解法

时间：O(n)

空间：O(1)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
var removeElements = function(head, val) {
  	//为什么需要虚拟结点
    let temp=new ListNode(0,head)
    let p=temp
    let q=head
    while(q!==null){
        if(q.val!==val){
            p=q
            q=p.next
        }else{
          	//删除节点，如何删除的是头结点，没有虚拟节点的话，这段代码就没有用
          	//需要操作前一个节点的next属性，如果是头节点，pre===head，head并没有next属性值
            p.next=q.next
          //移动到下一个需要操作的节点
            q=q.next
        }
    }
    return temp.next
};
```



# LeetCode 707.设计链表

## 思路

主要看是考察对链表的理解，有几个注意点：

- 在链表的尾部添加节点时，如果此时链表是空的，需要特殊处理，转换成在链表头部添加节点

## 解法

```javascript

var MyLinkedList = function() {
    this.head={
        val:null,
        next:null
    }
    this.length=0
};

/** 
 * @param {number} index
 * @return {number}
 */
MyLinkedList.prototype.get = function(index) {
    let i=0
    let curr=this.head.next
    if(index<0||index>=this.length){
        return -1
    }
    while(i<index){
        curr=curr.next
        i++
    }
    return curr.val
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtHead = function(val) {
    let node={
        val,
        next:this.head.next
    }
    this.head.next=node
    this.length++
};

/** 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtTail = function(val) {
    if(this.length===0){
        return this.addAtHead(val)
    }
    let node={
        val,
        next:null
    }
    let curr=this.head.next
    let i=0
    while(i<this.length-1){
        curr=curr.next
        i++
    }
    curr.next=node
    this.length++
};

/** 
 * @param {number} index 
 * @param {number} val
 * @return {void}
 */
MyLinkedList.prototype.addAtIndex = function(index, val) {
    if(index<0||index>this.length) return;
    let node={
        val,
        next:null
    }
    let pre=this.head
    let curr=this.head.next
    let i=0
    while(i<index){
        pre=curr
        curr=pre.next
        i++
    }
    pre.next=node
    node.next=curr
    this.length++
};

/** 
 * @param {number} index
 * @return {void}
 */
MyLinkedList.prototype.deleteAtIndex = function(index) {
    if(index<0||index>=this.length) return;
    let pre=this.head
    let curr=this.head.next
    let i=0
    while(i<index){
        pre=curr
        curr=curr.next
        i++
    }
    pre.next=curr.next
    this.length--
};
```



# LeetCode 206.反转链表 ⭐️

## 思路

首先考虑声明定义几个指针，至少需要一个指向当前操作节点的**指针curr**，因为需要将当前节点的next指向上一个节点，所以还需要一个**指针prev**来维护上一个节点的地址，**每次迭代循环要做的就是把curr.next指向prev**，操作完当前节点，同时向后移动到下次需要操作的节点，**循环的终止条件就是curr指向null**，表示已经没有需要继续操作的节点了

## 解法一 迭代

时间：O(n)

空间：O(1)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  	//不需要创建dummy节点，因为while代码中没有访问pre节点的内部属性
    let pre=null //直接初始化为null，这样反转第一个节点时不需要做特殊的处理了
    let curr=head
    while(curr!==null){
        const next=curr.next
        curr.next=pre
        pre=curr
        curr=next
    }
    return pre
};
```

