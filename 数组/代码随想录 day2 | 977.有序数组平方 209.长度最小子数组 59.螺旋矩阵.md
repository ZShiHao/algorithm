# LeetCode 977.有序数组平方

**关键点：有序数组 非递减（可包含相同元素的递增） 整型元素**

## 思路

### 排序

这道题直接能想到的方法就是**排序法**，先计算平方，然后再排序。但是排序的话时间复杂度最快也需要**O(nlogn)**，那么是否可以进一步优化时间复杂度到**O(n)**呢

### 双指针(交界指针)

对于**数组的O(n)**很容易想到可以用**双指针**的方法，再具体分析题目，负数平方后是由大到小，正数平方后是又小到大，相当于可以把整个数组分解为**两个子数组**，这两个子数组内部都是有序的（一个递增，一个递减），我们只需要找到**两个子数组交界**的地方，**两个指针**分别指向子数组最小的元素，同时**遍历并比较两个子数组**元素把小的放到新数组中就可以实现**O(n)**

### 双指针(首尾指针)

在代码实现找交界双指针的方法时，发现要处理的临界条件非常多，代码复杂容易出错，再仔细分析一下题目的关键点，发现有更加简洁的双指针实现方法，对于**正负两个子数组**，我们不需要找到找到**正负交界**就可以遍历比较，找交界是为了找到**最小的元素**实现**从小到大**插入到新数组，实际上对于排序也可以把思维反过来找到**最大的元素**实现**从大到小**的插入，数组的首尾两个元素就是正负两个子数组各自最大的元素，通过首尾指针直接就可以遍历比较，省去了遍历查找交界的循环

## 解法一 双指针(交界指针)

时间复杂度：O(n)

空间复杂度：O(1)

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function(nums) {
    let arr=[]
    if(nums.length===1){
        arr[0]=nums[0]*nums[0]
        return arr
    }
    let left=0 //指向负数子数组的指针
    let right=1 //指向正数子数组的指针
    //第一次遍历找到数组正负交界的地方
    while(right<nums.length){
        if(nums[left]<0&&nums[right]>=0){
            break
        }else{
            left++
            right++
        }
    }
    if(right===nums.length&&nums[left]>0){
        left=-1
        right=0
    }
    let i=0
    //第二次遍历，同时遍历两个子数组比较排序
    while(left>=0||right<nums.length){
        if(left<0){
            arr[i++]=nums[right]*nums[right]
            right++
        }else if(right===nums.length){
            arr[i++]=nums[left]*nums[left]
            left--
        }else{
            let l_num=nums[left]*nums[left]
            let r_num=nums[right]*nums[right]
            if(l_num===r_num){
                arr[i++]=l_num
                arr[i++]=l_num
                left--
                right++
            }else if(l_num<r_num){
                arr[i++]=l_num
                left--
            }else{
                arr[i++]=r_num
                right++
            }
        }
    }
    return arr
};
```

## 解法二 双指针(首尾指针)

时间复杂度：O(n)

空间复杂度：O(1)

对比解法一这种方法非常的简洁

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortedSquares = function(nums) {
    let arr=new Array(nums.length)
    let start=0
    let end=nums.length-1
    let n=nums.length-1
    //临界条件和二分查找的很像，都是区间是否还有未处理的元素
    //这种临界条件也不用考虑指针溢出的特殊情况
    while(start<=end){
        if(nums[end]*nums[end]>nums[start]*nums[start]){
            arr[n--]=nums[end]*nums[end]
            end--
        }else{
            arr[n--]=nums[start]*nums[start]
            start++
        }
    }
    return arr
};
```



# LeetCode 209.长度最小子数组 ⭐️

**关键点：数组 正整数 子数组**

## 思路

首先想到的是暴力解法，两层for循环可以遍历出所有的可能出现的子序列，对于数组又是双层for循环，很容易想到用**双指针**的方式去代替for循环，双指针包含的区间就是要计算的子数组，每次循环都需要先计算当前子数组的总和，**如果当前子数组的和大于等于target，就需要不断向左移动start指针减小子数组，看当前区间内是否有更小的子数组**（做题时思路没问题，但是代码没有写出来，就是因为循环中又套了这一层循环，潜意识觉得时O(n^2)，实际上是O(2n)），**直到子数组总和小于target**，**此时就需要end指针向右移动来增大子数组的大小**

## 解法一 双指针（滑动窗口）

时间：O(n)

空间：O(1)

```javascript
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
    let start=0
    let end=0
    let l=Infinity //长度初始化为无穷大，方便后面首次更新长度
    let sum=0
    while(end<nums.length){
        sum+=nums[end]
        while(sum>=target){
          //当前窗口满足条件，缩小窗口查看是否有更短的满足条件的子数组
            l=Math.min(l,(end-start+1))
            sum-=nums[start]
            start++
        }
        end++
    }
    return l===Infinity?0:l
};
```



# LeetCode 59.螺旋矩阵

## 思路

这题没有什么捷径，就是按照描述定义好**上下左右**四个边界，**每个边界都用for循环依次赋值**，每条边界赋值完之后更新边界的值，四个边界按顺时针的方式都for循环一遍，此时最外层的一圈都已经赋值，而且**四条边界也已经更新为往内的一圈**，开始下次循环，外层的while循环终止条件等于n^n即可，因为n^n时，矩阵中的所有元素都一定被赋值了

## 解法一 模拟

时间：O(n^n)

空间：O(1)

```javascript
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function(n) {
    let arr=[]
    //声明一个二维数组
    for(let i=0;i<n;i++){
        arr[i]=[]
    }
    let t=0
    let r=n-1
    let b=n-1
    let l=0
    let num=1
    while(num<=n*n){
        //填充上边界
        for(let i=l;i<=r;i++){
            arr[t][i]=num++
        }
        t++;//更新上边界
        for(let i=t;i<=b;i++){
            arr[i][r]=num++
        }
        r--;
        for(let i=r;i>=l;i--){
            arr[b][i]=num++
        }
        b--;
        for(let i=b;i>=t;i--){
            arr[i][l]=num++
        }
        l++;
    }
    return arr
};
```

