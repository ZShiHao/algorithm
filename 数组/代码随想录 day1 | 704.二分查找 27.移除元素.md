# LeetCode 704.二分查找

**关键点: 数组 有序 无重复 整型元素**

## 思路

对于**有序的整型数组**查找其中的某个元素，都可以使用二分查找。

二分查找首先是要确定查找区间[left,right]，每次循环都先找到区间的中位数进行比较（mid=(left+right)/2），确定下次的查找区间是在左侧还是右侧，然后更新下次的查找区间（**left=mid+1、right=mid-1**）

二分查找比较容易出问题的就是**临界条件**容易出错，下面是**注意点**：

- 更新查找区间是要mid+1或者mid-1，因为mid这个数已经参与过比较了，所以下次的查找区间可以不包括mid
- **while(left<=right)**，循环的终止条件时left>right，此时区间已经不是一个合理的区间了，区间里已经没有任何元素了，可以考虑一个极端的情况，查到一个无穷大的数，此时左区间left会一直往右侧移动直到溢出

## 解法一  暴力解法

时间复杂度：O(n)

空间复杂度：O(1)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    for(let i=0;i<nums.length;i++){
        if(nums[i]===target){
            return i
        }
    }
    return -1
};
```

## 解法二  二分查找

时间复杂度：O(logn)

空间复杂度：O(n)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left=0
    let right=nums.length-1
    while(left<=right){
        let mid=Math.floor(left+(right-left)/2) //防止溢出
        if(nums[mid]===target){
            return mid
        }else if(nums[mid]<target){
            left=mid+1
        }else if(nums[mid]>target){
            right=mid-1
        }
    }
    return -1
};
```

# LeetCode 27.移除元素

**关键点：数组 原地移除 不能稀疏**

## 思路

首先这道题很容易想到的就是用双层for循环的暴力解法，但是这样的话时间复杂度直接爆炸，看到**数组**的**双层for循环**，我首先想到的就是用**双指针**来优化，用一个指针来代替掉一个外层的for循环

## 双指针

时间复杂度：O(n)

空间复杂度：O(1)

```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let slow=0
    let fast=0
    while(fast<nums.length){
        if(nums[fast]===val){
            fast++;
        }else{
            nums[slow++]=nums[fast++]
        }
    }
    return slow
};
```

