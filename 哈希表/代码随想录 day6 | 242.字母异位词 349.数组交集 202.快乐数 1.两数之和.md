# LeetCode 242.字母异位词

## 思路

遍历其中一个字符串，统计每个字符出现的次数并保存到哈希表中，然后遍历另一个字符串，将哈希表中每个字符出现的次数减一，如果是字母异位词，遍历之后哈希表中的值应该全是0

## 解法一 哈希表

时间：O(n)

空间：O(n)

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if(s.length!==t.length) return false
    let map=new Map()
    for(let value of s){
        if(map.has(value)){
            map.set(value,map.get(value)+1)
        }else{
            map.set(value,1)
        }
    }
    for(let value of t){
        if(map.has(value)){
            if(map.get(value)-1<0){
                return false
            }else{
                map.set(value,map.get(value)-1)
            }
        }else{
            return false
        }
    }
    return true
};
```



# LeetCode 349.两个数组的交集

## 思路

先去重，再遍历另一个数组

## 解法一 Map

时间：O(n)

空间：O(n)

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    let map=new Map()
    for(let value of nums1){
        if(!map.has(value)){
            map.set(value,false)
        }
    }
    for(let value of nums2){
        if(map.has(value)){
            map.set(value,true)
        }
    }
    let arr=[]
    for(let res of map.entries()){
        if(res[1]){
            arr.push(res[0])
        }
    }
    return arr
};
```

## 解法二 一行代码秒了 ⭐️

时间：O(m*n)

空间：O(n)

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    return Array.from(new Set(nums1.filter(value=>nums2.includes(value))))
};
```



# LeetCode 202.快乐数

## 思路

计算机中存储一个整型数是有最大值的限制的，所以平方和也是有最大的限制的，而整数个数又是一定的，所以**题目中所说的无限循环就代表一定是循环计算中出现了重复的数，才会进入到无限循环**，把每次计算后的平方和都放到哈希集合中

## 解法一 集合 ⭐️

时间：O(logn)

空间：O(logn)

```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let set = new Set()
    while(n!==1&&!set.has(n)){
        set.add(n)
        let sum=0
        let temp=n
        while(temp>0){
            let d=temp%10
            sum+=d*d
            temp=Math.floor(temp/10)
        }
        n=sum
    }
    return n===1
};
```



# LeetCode 1.两数之和 ⭐️

## 思路

寻找数组中的两数之和等于target的两个数可以变一种问法，**就是当遍历数组时判断target-nums[i]这个数是否存在于数组中**，对于查找某个元素是否存在于集合中，首先就是想到用map和set，这道题不止需要判断是否存在还有返回下标，所以只能用map

## 解法一 map哈希表

时间：O(n)

空间：O(n)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let map=new Map()
    for(let i=0;i<nums.length;i++){
        if(map.has(target-nums[i])){
            return [map.get(target-nums[i]),i]
        }
        map.set(nums[i],i)
    }
};
```

