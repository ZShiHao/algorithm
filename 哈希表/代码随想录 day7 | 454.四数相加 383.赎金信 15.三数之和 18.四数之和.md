# LeetCode 454.四数相加II ⭐️

## 思路

将四组数组**分为两组**，计算两组所有能出现的和的次数，并存储到map中，然后计算剩余两组数组所有的和，**0-sum看在map中是否存在**，如果存在把出现的次数累加起来。

## 解法一 分组+哈希表

时间：O(n*n)

空间：O(n*n)

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number[]} nums3
 * @param {number[]} nums4
 * @return {number}
 */
var fourSumCount = function(nums1, nums2, nums3, nums4) {
    let sum_map=new Map()
    //计算出前两个数组的所有可能出现的和的次数
    for(let i=0;i<nums1.length;i++){
        for(let j=0;j<nums2.length;j++){
            let sum=nums1[i]+nums2[j]
            if(sum_map.has(sum)){
                sum_map.set(sum,sum_map.get(sum)+1)
            }else{
                sum_map.set(sum,1)
            }
        }
    }
    let count=0
    for(let i=0;i<nums3.length;i++){
        for(let j=0;j<nums4.length;j++){
            let sum=nums3[i]+nums4[j]
            let target=0-sum
            if(sum_map.has(target)){
                count+=sum_map.get(target)
            }
        }
    }
    return count
};
```



# LeetCode 383.赎金信

## 思路

和242题基本一样，都是用哈希表统计字母出现的次数

## 解法一 哈希表

时间：O(n)

空间：O(n)

```javascript
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    let map=new Map()
    for(let i=0;i<magazine.length;i++){
        if(map.has(magazine[i])){
            map.set(magazine[i],map.get(magazine[i])+1)
        }else{
            map.set(magazine[i],1)
        }
    }
    for(let i=0;i<ransomNote.length;i++){
        if(map.has(ransomNote[i])&&(map.get(ransomNote[i])-1>=0)){
            map.set(ransomNote[i],map.get(ransomNote[i])-1)
        }else{
            return false
        }
    }
    return true
};
```



# LeetCode 15.三数之和 ⭐️

**关键点：整数数组 三元组不能重复 去重**

## 思路

**哈希表**

这道题很容易联想到两数之和，先用**两层for循环**遍历计算出所有的**两数之和sum**的情况，用一个**哈希表保存每个元素（也就是三数中的最后一个数）和数组下标的映射**，用0-target去找哈希表中找查找第三个数。

这种方法很容易找到所有的满足三数之和条件的三元组，但是这些三元组是有重复的，需要对三元组进行去重，但是**三元组的去重**是非常难处理的

**排序+双指针**

如果先将数组进行排序的话，我们就很容易找到数组中那些重复的元素了（都是相邻排列的），在遍历的时候就可以很容易得将这些重复的元素跳过从而实现去重了。

在每次遍历数组的时候：

- 声明**两个指针left和right，left=i+1，right=n-1**
- **每次遍历一个数组元素要做的是找到三元组中nums[i]的剩余两个数nums[left]和nums[right]**
- 如果**nums[i]>0**时，可以直接return退出执行了，因为后面的数三数相加一定是大于0的
- 计算三数之和时**sum=nums[i]+nums[left]+nums[right]**:
  - 如果**sum>0**，right**往左移动**找一个更小的数
  - 如果**sum<0**，left**往右移动**找一个更大的数
  - 如果**sum===0**，left和right就是需要找的两个数，接下来就是去重，right和left分别移动直到相邻元素不等于当前的答案nums[left]!==nums[left+1]
  - 循环的终止条件是left===right，此时没有剩余的元素需要计算了

## 解法一 排序+双指针

时间：O(n*n)

空间：O(1)

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    let ans=[]
    //原地排序
    nums.sort((a,b)=>a-b)
    for(let i=0;i<nums.length;i++){
        if(nums[i]>0) break;
        if(i-1>=0&&nums[i-1]===nums[i]) continue;
        let left=i+1
        let right=nums.length-1
        while(left<right){
            let sum=nums[i]+nums[left]+nums[right];
            if(sum>0){
                right--
            }else if(sum<0){
                left++
            }else{
                //sum===0
                //找到满足条件的三元组
                ans.push([nums[i],nums[left],nums[right]])
                //去重
                while(nums[left]===nums[left+1]){
                    left++
                }
                left++
                while(nums[right]===nums[right-1]){
                    right--
                }
                right--
            }
        }
    }
    return ans
};
```



# LeetCode 18.四数之和 ⭐️

## 思路

**排序+双指针**

和三数之和的题目基本一样，只是三个数相加变成四个数相加，相加的和从0变成了target，所以三数之和排序+双指针的方法也同样可以用，只需要在外面多一层for循环，将前两个数的和看作是三数之和的第一个数即可。

## 解法一 排序+双指针

时间：O(n*n*n)

空间：O(1)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    let ans=[]
    nums.sort((a,b)=>a-b)
    for(let i=0;i<nums.length;i++){
        if(i>0&&nums[i-1]===nums[i]) continue;
        for(let j=i+1;j<nums.length;j++){
            if(j>i+1&&nums[j-1]===nums[j]) continue;
            let firstSum=nums[i]+nums[j] //相当于三数之和中的第一个数
            let left=j+1
            let right=nums.length-1
            while(left<right){
                let sum=firstSum+nums[left]+nums[right]
                if(sum>target){
                    right--
                }else if(sum<target){
                    left++
                }else{
                    ans.push([nums[i],nums[j],nums[left],nums[right]])
                    //去重
                    while(nums[right-1]===nums[right]){
                        right--
                    }
                    right--
                    while(nums[left+1]===nums[left]){
                        left++
                    }
                    left++
                }
            }
        }
    }
    return ans
};
```

